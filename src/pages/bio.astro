---
import BaseLayout from '../layouts/BaseLayout.astro';
import FooterBio from '../components/FooterBio.astro';
import FullBiographyDifficultySelector from '../components/FullBiographyDifficultySelector.astro';
import FullBiographyContent from '../components/FullBiographyContent.astro';
import { DEFAULT_DIFFICULTY } from '../data/full-biography-difficulty';

const title = 'Bio';
const description = 'About Emily - kinda';
const permalink = `${Astro.site.href}bio`;

// Create fake frontmatter for the difficulty selector version
const frontmatter = {
  title: 'A Bio, kind of',
  publishDate: '20 Aug 2025'
};

// Estimate reading times for different difficulty levels
const estimatedReadingTimes = {
  tutorial: '< 1 min read',
  'story-mode': '1 min read',
  normal: '3 min read',
  hard: '5 min read',
  maddening: '8 min read'
};
---

<BaseLayout title={title} description={description} permalink={permalink} current="bio">
  <header>
    <p id="reading-time-display">{frontmatter.publishDate} ~ 3 min read</p>
    <h1>{frontmatter.title}</h1>
    <hr />
  </header>
  <div class="container">
    <FullBiographyDifficultySelector defaultLevel={DEFAULT_DIFFICULTY} />
    <FullBiographyContent currentLevel={DEFAULT_DIFFICULTY} />
    <hr />
    <div class="back-to-blog">
      <a href="/blog">→ View blog posts</a>
      <a href="/thoughts">→ View thoughts</a>
      <a href="/museum">→ Visit the MUSEUM???</a>
    </div>
    <FooterBio />
  </div>
</BaseLayout>

<script define:vars={{ estimatedReadingTimes }}>
  class FullBiographyDifficultyManager {
    currentDifficulty;
    buttons;
    textElements;
    readingTimeDisplay;
    STORAGE_KEY = 'full-biography-difficulty';
    readingTimes;
    MAX_RETRY_COUNT = 10;
    currentRetryCount = 0;
    RETRY_DELAY_MS = 100;

    constructor() {
      this.currentDifficulty = 'tutorial'; // Default difficulty
      this.buttons = document.querySelectorAll('.difficulty-btn');
      this.textElements = document.querySelectorAll('[data-difficulty-content]');
      this.readingTimeDisplay = document.getElementById('reading-time-display');
      this.readingTimes = estimatedReadingTimes;
      
      // Mark all content as JS initialized to remove default CSS
      this.textElements.forEach(el => el.classList.add('js-initialized'));
      
      this.init();
    }

    init() {
      // Ensure content elements exist
      if (this.textElements.length === 0) {
        // Prevent infinite loop with max retry count
        if (this.currentRetryCount >= this.MAX_RETRY_COUNT) {
          console.error('Biography content failed to load after maximum retries');
          return;
        }
        
        this.currentRetryCount++;
        console.warn(`Biography content not loaded yet, retrying... (attempt ${this.currentRetryCount}/${this.MAX_RETRY_COUNT})`);
        
        setTimeout(() => {
          this.textElements = document.querySelectorAll('[data-difficulty-content]');
          this.textElements.forEach(el => el.classList.add('js-initialized'));
          this.init();
        }, this.RETRY_DELAY_MS);
        return;
      }
      
      // Load saved preference from localStorage first
      const savedDifficulty = this.loadSavedDifficulty();
      if (savedDifficulty && this.isValidDifficulty(savedDifficulty)) {
        this.currentDifficulty = savedDifficulty;
      }
      
      // Set initial active states
      this.updateDisplay();
      
      // Add click handlers to buttons
      this.buttons.forEach(button => {
        button.addEventListener('click', (e) => {
          const target = e.currentTarget;
          const difficultyId = target.dataset.difficulty;
          if (difficultyId && this.isValidDifficulty(difficultyId)) {
            this.setDifficulty(difficultyId);
          }
        });

        // Add keyboard support
        button.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            button.click();
          }
        });
      });

      // Add keyboard navigation between buttons
      this.addKeyboardNavigation();
    }

    addKeyboardNavigation() {
      this.buttons.forEach((button, index) => {
        button.addEventListener('keydown', (e) => {
          let targetIndex = index;
          
          switch(e.key) {
            case 'ArrowLeft':
            case 'ArrowUp':
              e.preventDefault();
              targetIndex = index > 0 ? index - 1 : this.buttons.length - 1;
              break;
            case 'ArrowRight':
            case 'ArrowDown':
              e.preventDefault();
              targetIndex = index < this.buttons.length - 1 ? index + 1 : 0;
              break;
            case 'Home':
              e.preventDefault();
              targetIndex = 0;
              break;
            case 'End':
              e.preventDefault();
              targetIndex = this.buttons.length - 1;
              break;
          }
          
          if (targetIndex !== index) {
            this.buttons[targetIndex].focus();
          }
        });
      });
    }

    isValidDifficulty(difficulty) {
      return ['tutorial', 'story-mode', 'normal', 'hard', 'maddening'].includes(difficulty);
    }

    loadSavedDifficulty() {
      try {
        return localStorage.getItem(this.STORAGE_KEY);
      } catch (error) {
        console.warn('Failed to load difficulty preference from localStorage:', error);
        return null;
      }
    }

    saveDifficulty(difficulty) {
      try {
        localStorage.setItem(this.STORAGE_KEY, difficulty);
      } catch (error) {
        console.warn('Failed to save difficulty preference to localStorage:', error);
      }
    }

    setDifficulty(difficultyId) {
      this.currentDifficulty = difficultyId;
      this.updateDisplay();
      this.saveDifficulty(difficultyId);
      
      // Trigger custom event for potential analytics/tracking
      window.dispatchEvent(new CustomEvent('full-biography-difficulty-changed', {
        detail: { difficulty: difficultyId }
      }));
    }

    updateDisplay() {
      // Update button states
      this.buttons.forEach(button => {
        const isActive = button.dataset.difficulty === this.currentDifficulty;
        button.classList.toggle('active', isActive);
        button.setAttribute('aria-pressed', isActive.toString());
      });

      // Update text visibility with smooth transitions
      this.textElements.forEach(element => {
        const isVisible = element.dataset.difficultyContent === this.currentDifficulty;
        
        if (isVisible) {
          // Show the active content
          element.style.display = 'block';
          element.classList.add('active');
          element.classList.add('fade-in');
          element.classList.remove('fade-out');
        } else {
          // Hide inactive content
          element.classList.remove('active', 'fade-in');
          element.classList.add('fade-out');
          
          // Hide after transition
          setTimeout(() => {
            if (!element.classList.contains('active')) {
              element.style.display = 'none';
            }
          }, 400);
        }
      });

      // Update reading time display
      if (this.readingTimeDisplay && this.readingTimes[this.currentDifficulty]) {
        const currentText = this.readingTimeDisplay.textContent || '';
        const newText = currentText.replace(/\d+\s*min read|<\s*\d+\s*min read/, this.readingTimes[this.currentDifficulty]);
        this.readingTimeDisplay.textContent = newText;
      }
    }

    // Fallback method for when content is missing
    getFallbackContent() {
      const fallbackOrder = ['tutorial', 'normal', 'story-mode'];
      
      for (const difficulty of fallbackOrder) {
        const element = document.querySelector(`[data-difficulty-content="${difficulty}"]`);
        if (element) {
          return difficulty;
        }
      }
      
      return 'tutorial'; // Ultimate fallback
    }
  }

  // Initialize when DOM is ready
  let difficultyManagerInstance = null;
  const FALLBACK_INIT_DELAY_MS = 300; // Delay for fallback initialization
  
  function initializeFullBiographyDifficulty() {
    // Prevent multiple initializations
    if (difficultyManagerInstance) {
      return;
    }
    
    if (document.querySelector('.difficulty-btn')) {
      difficultyManagerInstance = new FullBiographyDifficultyManager();
    }
  }

  // Multiple initialization strategies for reliability
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeFullBiographyDifficulty);
  } else {
    initializeFullBiographyDifficulty();
  }
  
  // Handle Astro client-side navigation
  document.addEventListener('astro:page-load', () => {
    difficultyManagerInstance = null; // Reset on navigation
    initializeFullBiographyDifficulty();
  });
  
  // Fallback for slow content loading
  setTimeout(initializeFullBiographyDifficulty, FALLBACK_INIT_DELAY_MS);

  // Graceful degradation: if JavaScript fails, show tutorial difficulty
  window.addEventListener('error', () => {
    const tutorialContent = document.querySelector('[data-difficulty-content="tutorial"]');
    if (tutorialContent) {
      tutorialContent.style.display = 'block';
      tutorialContent.style.position = 'relative';
      tutorialContent.classList.add('active');
    }
  });
</script>

<!-- Fallback for when JavaScript is disabled -->
<noscript>
  <style>
    [data-difficulty-content]:not([data-difficulty-content="tutorial"]) {
      display: none !important;
    }
    [data-difficulty-content="tutorial"] {
      display: block !important;
      position: relative !important;
      opacity: 1 !important;
      transform: none !important;
    }
    .biography-difficulty-selector {
      display: none !important;
    }
  </style>
</noscript>

<style>
  header {
    text-align: center;
  }

  header h1 {
    margin-bottom: 0.7em;
  }

  header p {
    color: var(--text-secondary);
    text-transform: uppercase;
    font-family: var(--font-family-sans);
    font-weight: 600;
  }

  header hr {
    min-width: 100px;
    width: 30%;
  }

  .back-to-blog {
    text-align: center;
    margin: 2em 0;
  }

  .back-to-blog a {
    color: var(--text-secondary);
    text-decoration: none;
    font-family: var(--font-family-sans);
    font-weight: 600;
    display: block;
    margin: 0.5em 0;
  }

  .back-to-blog a:hover {
    text-decoration: underline;
  }
</style>
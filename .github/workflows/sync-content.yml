name: Sync Content to Database

on:
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update all content (even if unchanged)'
        required: false
        type: boolean
        default: false

jobs:
  sync-content:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'package-lock.json'
      
      - name: Install wrangler
        run: npm install -g wrangler
      
      - name: Sync content to database
        run: |
          echo "üîç Scanning filesystem for content..."
          
          # Debug: Check if token is set
          if [ -z "$CLOUDFLARE_API_TOKEN" ]; then
            echo "‚ùå CLOUDFLARE_API_TOKEN is not set!"
            exit 1
          else
            echo "‚úÖ CLOUDFLARE_API_TOKEN is set (length: ${#CLOUDFLARE_API_TOKEN})"
          fi
          
          # Get existing slugs from database
          echo "üìä Getting existing slugs from database..."
          
          # First, let's verify we can connect and the table exists
          echo "Checking table structure..."
          wrangler d1 execute baba-is-win-db --remote --command "SELECT COUNT(*) as count FROM content_items;" --json || {
            echo "‚ùå Failed to query content_items table"
            echo "Make sure CLOUDFLARE_API_TOKEN secret is set in GitHub with D1:Edit permissions"
            exit 1
          }
          
          # Now get the slugs
          raw_response=$(wrangler d1 execute baba-is-win-db --remote --command "SELECT slug FROM content_items;" --json)
          echo "Raw response from D1:"
          echo "$raw_response" | jq . || echo "$raw_response"
          
          # Parse response - wrangler d1 returns: [{"results": [...], "success": true, "meta": {...}}]
          existing_slugs=$(echo "$raw_response" | jq -r '.[0].results[].slug' 2>/dev/null | sort | uniq)
          
          # If that didn't work, try alternative formats
          if [ -z "$existing_slugs" ]; then
            echo "First parsing attempt failed, trying alternative formats..."
            existing_slugs=$(echo "$raw_response" | jq -r 'try .results[].slug // try .[].results[].slug // empty' 2>/dev/null | sort | uniq)
          fi
          
          if [ -z "$existing_slugs" ]; then
            echo "‚ö†Ô∏è Warning: Could not parse existing slugs from database response"
            echo "Will treat all content as new"
            existing_slugs=""
          else
            slug_count=$(echo "$existing_slugs" | wc -l | tr -d ' ')
            echo "‚úÖ Found $slug_count existing slugs in database"
            echo "$existing_slugs"
          fi
          
          # Collect all filesystem content first
          echo "üìù Scanning filesystem for all content..."
          blog_files=(src/data/blog-posts/published/*.md)
          thought_files=(src/data/thoughts/published/*.md)
          
          new_content_count=0
          
          # Process blog posts
          echo "üìù Processing blog posts..."
          for blog_file in "${blog_files[@]}"; do
            if [ -f "$blog_file" ]; then
              slug=$(basename "$blog_file" .md)
              
              # Check if slug already exists (handle empty existing_slugs)
              if [ -z "$existing_slugs" ] || ! echo "$existing_slugs" | grep -q "^$slug$"; then
                echo "‚ûï Adding new blog post: $slug"
                
                # Extract metadata from file and escape single quotes
                title=$(grep "^title:" "$blog_file" | sed 's/title: *//' | sed 's/^"//' | sed 's/"$//' | sed "s/'/''/g")
                description=$(grep "^description:" "$blog_file" | sed 's/description: *//' | sed 's/^"//' | sed 's/"$//' | sed "s/'/''/g")
                publish_date=$(grep "^publishDate:" "$blog_file" | sed 's/publishDate: *//')
                
                # Convert date to Unix timestamp
                publish_timestamp=$(date -d "$publish_date" +%s 2>/dev/null || date -j -f "%d %b %Y" "$publish_date" +%s 2>/dev/null || echo "0")
                
                # Insert into database with properly escaped values
                wrangler d1 execute baba-is-win-db --remote --command "
                  INSERT INTO content_items (slug, content_type, title, description, publish_date, file_path, notification_sent, created_at)
                  VALUES ('$slug', 'blog', '$title', '$description', $publish_timestamp, '$blog_file', 0, datetime('now'));
                "
                ((new_content_count++))
              else
                echo "‚úÖ Blog post already exists: $slug"
              fi
            fi
          done
          
          # Process thoughts
          echo "üí≠ Processing thoughts..."
          for thought_file in "${thought_files[@]}"; do
            if [ -f "$thought_file" ]; then
              slug=$(basename "$thought_file" .md)
              
              # Check if slug already exists (handle empty existing_slugs)
              if [ -z "$existing_slugs" ] || ! echo "$existing_slugs" | grep -q "^$slug$"; then
                echo "‚ûï Adding new thought: $slug"
                
                # Extract metadata from file and escape single quotes
                title=$(grep "^title:" "$thought_file" | sed 's/title: *//' | sed 's/^"//' | sed 's/"$//' | sed "s/'/''/g")
                publish_date=$(grep "^publishDate:" "$thought_file" | sed 's/publishDate: *//')
                
                # Convert date to Unix timestamp
                publish_timestamp=$(date -d "$publish_date" +%s 2>/dev/null || date -j -f "%d %b %Y" "$publish_date" +%s 2>/dev/null || echo "0")
                
                # Insert into database with properly escaped values
                wrangler d1 execute baba-is-win-db --remote --command "
                  INSERT INTO content_items (slug, content_type, title, publish_date, file_path, notification_sent, created_at)
                  VALUES ('$slug', 'thought', '$title', $publish_timestamp, '$thought_file', 0, datetime('now'));
                "
                ((new_content_count++))
              else
                echo "‚úÖ Thought already exists: $slug"
              fi
            fi
          done
          
          echo "üìä Summary: Added $new_content_count new content items"
          
          echo "‚úÖ Content sync completed successfully"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      
      - name: Check content status after sync
        continue-on-error: true
        run: |
          echo ""
          echo "Checking content and notification status after sync..."
          
          response=$(curl -X GET https://personal.emily-cogsdill.workers.dev/api/admin/check-notifications \
            -H "x-cron-secret: ${{ secrets.CRON_SECRET }}" \
            -H "Content-Type: application/json" \
            -w "\nHTTP_STATUS:%{http_code}\n" \
            -s 2>&1) || true
          
          # Extract HTTP status
          http_status=$(echo "$response" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2 || echo "000")
          body=$(echo "$response" | sed '/HTTP_STATUS:/d')
          
          if [ "$http_status" = "401" ]; then
            echo "‚ö†Ô∏è Skipping notification check - CRON_SECRET may be incorrect"
            echo "To enable this check, verify CRON_SECRET in GitHub secrets matches your Cloudflare secret"
          elif [ "$http_status" = "200" ]; then
            echo "$body" | jq '{
              summary,
              unnotifiedContent: .unnotifiedContent | map({slug, type, title, isNotified}),
              totalUnnotified: .unnotifiedContent | length
            }' || echo "$body"
          else
            echo "‚ö†Ô∏è Could not check notifications - HTTP status: $http_status"
            echo "Response: $body"
          fi
      
      - name: Show sync summary
        run: |
          echo ""
          echo "=== SYNC SUMMARY ==="
          echo "1. Content has been synced from markdown files to database"
          echo "2. Check the unnotifiedContent above to see what needs notification"
          echo "3. To send notifications, use the 'Process Email Notifications' workflow"
          echo "4. To force re-notification of content, use the 'Reset Notifications' workflow first"